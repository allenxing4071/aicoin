# ⚙️ 智能约束框架技术文档

> **提取自**: AI交易规则文档 第二部分  
> **版本**: v2.0  
> **状态**: Phase 1核心实现

---

## 📋 目录

1. [核心概念](#核心概念)
2. [动态权限系统（L0-L5）](#动态权限系统)
3. [保护性约束（硬限制）](#保护性约束)
4. [指导性约束（软限制）](#指导性约束)
5. [Prompt设计](#prompt设计)
6. [技术实现路线](#技术实现路线)

---

## 1. 核心概念

### 1.1 设计理念

**问题回顾**：初始测试(-48.8%亏损)暴露的问题
- ❌ AI陷入"疯狂加仓"死循环
- ❌ 缺少风控约束
- ❌ Prompt设计过于激进

**解决方案**：智能约束框架

```
┌─────────────────────────────────────┐
│      AI自主决策空间                  │
│                                     │
│  ┌──────────────────────────┐      │
│  │   指导性约束（软限制）     │      │
│  │   - 置信度门槛            │      │
│  │   - 频率建议              │      │
│  │   - 仓位指导              │      │
│  └──────────────────────────┘      │
│                                     │
│  ┌──────────────────────────┐      │
│  │   保护性约束（硬限制）     │      │
│  │   - 绝对红线              │      │
│  │   - 不可突破              │      │
│  └──────────────────────────┘      │
│                                     │
│  底层：L0-L5动态权限系统            │
└─────────────────────────────────────┘
```

**核心特点**：
1. **动态演进** - 权限随表现自动调整
2. **软硬结合** - 硬约束保护+软约束指导
3. **AI友好** - 在Prompt中透明告知规则
4. **人工兜底** - 极端情况人工介入

---

## 2. 动态权限系统

### 2.1 权限等级定义

| 等级 | 名称 | 单仓位 | 杠杆 | 置信度门槛 | 日频率 | 升级条件 |
|------|------|--------|------|-----------|--------|---------|
| **L0** | 保护模式 | 0% | 1x | 100% | 0 | 人工审核 |
| **L1** | 新手级 | 10% | 2x | 80% | 1 | 7天+50%胜率 |
| **L2** | 成长级 | 12% | 2x | 75% | 2 | 30天+夏普1.0 |
| **L3** | 稳定级 | 15% | 3x | 70% | 4 | 60%胜率+夏普1.5 |
| **L4** | 熟练级 | 20% | 4x | 65% | 6 | 70%胜率+20天连盈 |
| **L5** | 专家级 | 25% | 5x | 60% | 无限 | 最高等级 |

### 2.2 权限管理实现

#### 2.2.1 权限评估逻辑

```python
# backend/app/services/permission_manager.py

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional

@dataclass
class PerformanceData:
    """性能数据结构"""
    win_rate_7d: float
    win_rate_30d: float
    sharpe_ratio: float
    max_drawdown: float
    consecutive_losses: int
    total_trades: int
    profitable_trades: int
    days_active: int
    profit_consistency: float = 0.0
    consecutive_profitable_days: int = 0

class PermissionManager:
    """
    权限管理器
    负责评估AI表现并动态调整权限等级
    """
    
    def __init__(self, db_session):
        self.db = db_session
    
    async def evaluate_permission_level(
        self,
        current_level: str,
        performance_data: PerformanceData
    ) -> tuple[str, str]:
        """
        评估当前权限等级是否需要调整
        
        Returns:
            (new_level, reason)
        """
        
        # 1. 检查降级触发器（优先）
        downgrade_result = self._check_downgrade_triggers(
            current_level, 
            performance_data
        )
        if downgrade_result:
            return downgrade_result
        
        # 2. 检查升级条件
        upgrade_result = self._check_upgrade_conditions(
            current_level,
            performance_data
        )
        if upgrade_result:
            return upgrade_result
        
        # 3. 保持当前等级
        return current_level, "保持当前等级"
    
    def _check_downgrade_triggers(
        self,
        current_level: str,
        performance_data: PerformanceData
    ) -> Optional[tuple[str, str]]:
        """
        检查是否触发降级（风控优先）
        """
        
        # 触发L0（保护模式）的条件
        if any([
            performance_data.max_drawdown >= 0.10,  # 最大回撤≥10%
            performance_data.consecutive_losses >= 5,  # 连续5次亏损
        ]):
            return "L0", "触发风控保护"
        
        # 各等级降级逻辑
        if current_level == "L5":
            if performance_data.win_rate_30d < 0.65:
                return "L4", "近期表现下降"
        
        elif current_level == "L4":
            if performance_data.win_rate_30d < 0.55:
                return "L3", "近期表现下降"
        
        elif current_level == "L3":
            if performance_data.win_rate_7d < 0.45:
                return "L3", "近期表现下降"
        
        elif current_level == "L2":
            if performance_data.consecutive_losses >= 3:
                return "L1", "连续亏损，回到新手模式"
        
        return None
    
    def _check_upgrade_conditions(
        self,
        current_level: str,
        performance_data: PerformanceData
    ) -> Optional[tuple[str, str]]:
        """
        检查是否满足升级条件
        """
        
        # L0 → L1: 需要人工审核
        if current_level == "L0":
            return None  # 不自动升级
        
        # L1 → L2
        elif current_level == "L1":
            if (performance_data.days_active >= 7 and
                performance_data.win_rate_7d >= 0.50 and
                performance_data.max_drawdown < 0.15):
                return "L2", "新手期表现合格"
        
        # L2 → L3
        elif current_level == "L2":
            if (performance_data.days_active >= 30 and
                performance_data.win_rate_30d >= 0.50 and
                performance_data.sharpe_ratio >= 1.0 and
                performance_data.max_drawdown < 0.10):
                return "L3", "成长期表现优秀"
        
        # L3 → L4
        elif current_level == "L3":
            if (performance_data.win_rate_30d >= 0.60 and
                performance_data.sharpe_ratio >= 1.5 and
                performance_data.max_drawdown < 0.08 and
                performance_data.profit_consistency >= 0.7):
                return "L4", "稳定期表现卓越"
        
        # L4 → L5
        elif current_level == "L4":
            if (performance_data.win_rate_30d >= 0.70 and
                performance_data.sharpe_ratio >= 2.0 and
                performance_data.max_drawdown < 0.05 and
                performance_data.consecutive_profitable_days >= 20):
                return "L5", "达到专家水平"
        
        return None
    
    async def get_current_permission_config(self, level: str) -> dict:
        """
        获取当前权限等级的配置
        """
        return PERMISSION_LEVELS.get(level, PERMISSION_LEVELS["L1"])
```

#### 2.2.2 权限参数配置

```python
# backend/app/config/permissions.py

PERMISSION_LEVELS = {
    "L0": {
        "name": "保护模式",
        "max_position_pct": 0.0,        # 不允许开仓
        "max_leverage": 1,
        "confidence_threshold": 1.0,     # 实际上禁止交易
        "max_daily_trades": 0,           # 只能平仓
        "allow_new_positions": False,
        "description": "触发风控，需要人工审核"
    },
    "L1": {
        "name": "新手级",
        "max_position_pct": 0.10,        # 单仓位最大10%
        "max_leverage": 2,
        "confidence_threshold": 0.80,
        "max_daily_trades": 1,
        "allow_new_positions": True,
        "upgrade_conditions": {
            "min_days": 7,
            "min_win_rate_7d": 0.50,
            "max_drawdown": 0.15
        }
    },
    "L2": {
        "name": "成长级",
        "max_position_pct": 0.12,
        "max_leverage": 2,
        "confidence_threshold": 0.75,
        "max_daily_trades": 2,
        "allow_new_positions": True,
        "upgrade_conditions": {
            "min_days": 30,
            "min_win_rate_30d": 0.50,
            "min_sharpe_ratio": 1.0,
            "max_drawdown": 0.10
        }
    },
    "L3": {
        "name": "稳定级",
        "max_position_pct": 0.15,
        "max_leverage": 3,
        "confidence_threshold": 0.70,
        "max_daily_trades": 4,
        "allow_new_positions": True,
        "upgrade_conditions": {
            "min_win_rate_30d": 0.60,
            "min_sharpe_ratio": 1.5,
            "max_drawdown": 0.08,
            "min_profit_consistency": 0.7
        }
    },
    "L4": {
        "name": "熟练级",
        "max_position_pct": 0.20,
        "max_leverage": 4,
        "confidence_threshold": 0.65,
        "max_daily_trades": 6,
        "allow_new_positions": True,
        "upgrade_conditions": {
            "min_win_rate_30d": 0.70,
            "min_sharpe_ratio": 2.0,
            "max_drawdown": 0.05,
            "min_consecutive_profitable_days": 20
        }
    },
    "L5": {
        "name": "专家级",
        "max_position_pct": 0.25,
        "max_leverage": 5,
        "confidence_threshold": 0.60,
        "max_daily_trades": 999,         # 无限制
        "allow_new_positions": True,
        "upgrade_conditions": None       # 最高等级
    }
}
```

---

## 3. 保护性约束

### 3.1 账户安全约束

**绝对红线，任何权限等级都不可突破**：

```python
# backend/app/config/constraints.py

HARD_CONSTRAINTS = {
    # 1. 爆仓保护
    "min_margin_ratio": 0.20,           # 最低保证金率20%
    "forced_liquidation_threshold": 0.15,  # 15%强制平仓
    
    # 2. 最大回撤保护
    "max_total_drawdown": 0.10,         # 总账户最大回撤10%
    "max_single_trade_loss": 0.03,      # 单笔最大亏损3%
    
    # 3. 单日亏损保护
    "max_daily_loss": 0.05,             # 单日最大亏损5%
    "daily_loss_action": "STOP_TRADING", # 触发后停止交易
    
    # 4. 杠杆硬上限
    "absolute_max_leverage": 5,         # 绝对最大杠杆5x
    
    # 5. 流动性保护
    "min_cash_reserve": 0.10,           # 至少保留10%现金
    
    # 6. 单一资产集中度
    "max_single_asset_exposure": 0.30,  # 单一资产最大30%
}
```

### 3.2 硬约束验证

```python
# backend/app/services/constraint_validator.py

async def validate_hard_constraints(
    account_state: dict,
    proposed_trade: dict
) -> tuple[bool, str]:
    """
    验证硬性约束，任何违反都拒绝交易
    
    Returns:
        (is_valid, reason)
    """
    
    # 1. 检查保证金率
    if account_state["margin_ratio"] < HARD_CONSTRAINTS["min_margin_ratio"]:
        return False, "保证金率不足，禁止开新仓"
    
    # 2. 检查总回撤
    if account_state["total_drawdown"] >= HARD_CONSTRAINTS["max_total_drawdown"]:
        return False, "达到最大回撤限制，触发保护"
    
    # 3. 检查单日亏损
    if account_state["daily_loss"] >= HARD_CONSTRAINTS["max_daily_loss"]:
        return False, "超过单日亏损限制"
    
    # 4. 检查杠杆
    if proposed_trade["leverage"] > HARD_CONSTRAINTS["absolute_max_leverage"]:
        return False, f"杠杆超限：{proposed_trade['leverage']}x > 5x"
    
    # 5. 检查流动性
    available_cash = account_state["cash_balance"]
    required_reserve = account_state["total_value"] * HARD_CONSTRAINTS["min_cash_reserve"]
    if available_cash - proposed_trade["required_margin"] < required_reserve:
        return False, "现金储备不足"
    
    # 6. 检查单一资产集中度
    asset = proposed_trade["symbol"]
    current_exposure = account_state["asset_exposure"].get(asset, 0)
    new_exposure = current_exposure + proposed_trade["position_value"]
    if new_exposure / account_state["total_value"] > HARD_CONSTRAINTS["max_single_asset_exposure"]:
        return False, f"{asset}敞口过大"
    
    return True, "通过硬性约束检查"
```

### 3.3 强制平仓机制

```python
async def check_forced_liquidation(account_state: dict):
    """
    持续监控，触发条件时强制平仓
    """
    
    # 触发条件
    force_close_triggers = [
        # 1. 保证金率过低
        account_state["margin_ratio"] < HARD_CONSTRAINTS["forced_liquidation_threshold"],
        
        # 2. 单日亏损超限
        account_state["daily_loss"] >= HARD_CONSTRAINTS["max_daily_loss"],
        
        # 3. 总回撤超限
        account_state["total_drawdown"] >= HARD_CONSTRAINTS["max_total_drawdown"],
    ]
    
    if any(force_close_triggers):
        logger.critical("🚨 触发强制平仓条件")
        
        # 执行强制平仓
        positions = await get_all_positions()
        for position in positions:
            await force_close_position(
                position_id=position["id"],
                reason="触发风控保护",
                priority="URGENT"
            )
        
        # 降级到L0
        await set_permission_level("L0")
        
        # 发送告警
        await send_alert(
            level="CRITICAL",
            message="触发强制平仓，系统已进入保护模式",
            channels=["email", "sms", "telegram"]
        )
```

---

## 4. 指导性约束

### 4.1 置信度动态门槛

**核心思想**：置信度不是硬性拒绝，而是影响决策权重

```python
def apply_confidence_threshold(
    ai_decision: dict,
    current_level: str
) -> dict:
    """
    根据置信度和权限等级调整决策
    """
    
    confidence = ai_decision["confidence"]
    threshold = PERMISSION_LEVELS[current_level]["confidence_threshold"]
    
    # 高于门槛：正常执行
    if confidence >= threshold:
        ai_decision["status"] = "APPROVED"
        ai_decision["notes"] = "置信度达标"
        return ai_decision
    
    # 略低于门槛（-0.05内）：降低仓位执行
    elif confidence >= (threshold - 0.05):
        ai_decision["status"] = "APPROVED_REDUCED"
        ai_decision["size_usd"] *= 0.5  # 减半仓位
        ai_decision["notes"] = "置信度略低，减半仓位"
        return ai_decision
    
    # 明显低于门槛：拒绝
    else:
        ai_decision["status"] = "REJECTED"
        ai_decision["notes"] = f"置信度不足：{confidence} < {threshold}"
        return ai_decision
```

### 4.2 交易频率指导

```python
def apply_frequency_guidance(
    ai_decision: dict,
    current_level: str,
    today_trade_count: int
) -> dict:
    """
    频率不是强制，但超出建议需要更高置信度
    """
    
    max_daily = PERMISSION_LEVELS[current_level]["max_daily_trades"]
    
    # 在建议范围内：正常
    if today_trade_count < max_daily:
        return ai_decision
    
    # 超出建议：需要更高置信度
    else:
        required_confidence = 0.85  # 需要85%以上置信度
        
        if ai_decision["confidence"] >= required_confidence:
            ai_decision["notes"] = f"超出日频率建议({max_daily}次)，但置信度足够高"
            return ai_decision
        else:
            ai_decision["status"] = "REJECTED"
            ai_decision["notes"] = f"超出日频率且置信度不足"
            return ai_decision
```

### 4.3 仓位大小指导

```python
def apply_position_size_guidance(
    ai_decision: dict,
    current_level: str,
    account_balance: float
) -> dict:
    """
    根据权限等级和置信度调整仓位
    """
    
    max_pct = PERMISSION_LEVELS[current_level]["max_position_pct"]
    max_size = account_balance * max_pct
    
    proposed_size = ai_decision["size_usd"]
    
    # 在建议范围内：正常
    if proposed_size <= max_size:
        return ai_decision
    
    # 超出建议：自动调整
    else:
        logger.warning(
            f"AI建议仓位${proposed_size}超出权限${max_size}，"
            f"自动调整为权限上限"
        )
        ai_decision["size_usd"] = max_size
        ai_decision["size_adjusted"] = True
        ai_decision["original_size"] = proposed_size
        ai_decision["notes"] = f"仓位调整：{proposed_size} → {max_size}"
        
        return ai_decision
```

---

## 5. Prompt设计

### 5.1 改进后的Prompt模板

**核心变化**：
- ❌ 删除：过度激进的竞争语言
- ✅ 增加：动态权限信息和历史经验
- ✅ 强调：风险管理和长期主义

```python
def build_trading_prompt_v2(
    market_data: dict,
    account_state: dict,
    permission_level: str,
    recent_memory: list
) -> str:
    """
    改进后的Prompt，平衡约束与自主性
    """
    
    level_config = PERMISSION_LEVELS[permission_level]
    
    prompt = f"""你是一个专业的加密货币量化交易AI，使用DeepSeek V3模型。

═══════════════════════════════════════════════════════════
当前状态
═══════════════════════════════════════════════════════════

账户信息：
• 余额：${account_state['balance']:.2f}
• 权限等级：{level_config['name']} ({permission_level})
• 可用仓位：单笔最大 {level_config['max_position_pct']*100}%
• 置信度门槛：{level_config['confidence_threshold']}
• 今日已交易：{account_state['today_trades']}/{level_config['max_daily_trades']}次

市场数据：
{format_market_data(market_data)}

当前持仓：
{format_positions(account_state['positions'])}

═══════════════════════════════════════════════════════════
历史经验（最近10次类似情况）
═══════════════════════════════════════════════════════════

{format_recent_memory(recent_memory)}

═══════════════════════════════════════════════════════════
你的任务
═══════════════════════════════════════════════════════════

基于当前市场状态和历史经验，做出交易决策。

核心原则：
1. **本金保护第一**：任何时候都要考虑最坏情况
2. **长期主义**：追求稳定收益，不追求暴利
3. **风险收益平衡**：只在风险可控时才交易
4. **从历史中学习**：参考之前类似情况的成败

你的权限说明：
• 你处于{level_config['name']}，这是基于你的历史表现
• 单笔仓位最大{level_config['max_position_pct']*100}%
• 如果表现好，系统会自动提升你的权限
• 如果表现差，系统会自动降低你的权限以保护账户

决策建议：
• 优先考虑低频高胜率策略
• 建议每天不超过{level_config['max_daily_trades']}次交易（非强制）
• 开仓时同时设置止损和止盈
• 置信度不足时选择"hold"

═══════════════════════════════════════════════════════════
返回格式（JSON）
═══════════════════════════════════════════════════════════

{{
    "action": "open_long" | "open_short" | "close" | "hold",
    "symbol": "BTC" | "ETH" | "SOL",
    "size_usd": 123.45,
    "leverage": 2,
    "confidence": 0.85,
    "stop_loss_pct": 0.03,
    "take_profit_pct": 0.05,
    "reasoning": "你的决策理由（100字以内）"
}}

**重要提示**：
- confidence必须是你的真实信心水平（0-1之间）
- stop_loss和take_profit必须设置
- 如果不确定，选择"hold"是最安全的决策
"""
    
    return prompt
```

---

## 6. 技术实现路线

### 6.1 Phase 1 实现清单

**核心组件**：

```
✅ 必须实现：
├── PermissionManager（权限管理器）
├── ConstraintValidator（约束验证器）
├── PromptBuilder（Prompt构建器）
└── AlertSystem（告警系统）

⚠️ 集成要求：
├── 每次交易前验证硬约束
├── 每次交易后评估权限等级
├── 触发风控时立即告警
└── 日志记录所有决策和约束检查
```

### 6.2 集成流程

```python
# backend/app/services/ai_trading_service.py

class AITradingService:
    """
    AI交易服务（集成约束框架）
    """
    
    def __init__(self):
        self.permission_manager = PermissionManager(db)
        self.constraint_validator = ConstraintValidator()
        self.prompt_builder = PromptBuilder()
    
    async def make_trading_decision(self):
        """
        完整的决策流程
        """
        # 1. 获取当前权限等级
        current_level = await self.permission_manager.get_current_level()
        
        # 2. 获取账户状态
        account_state = await self.get_account_state()
        
        # 3. 检查是否触发强制平仓
        await check_forced_liquidation(account_state)
        
        # 4. 构建Prompt（包含权限信息）
        market_data = await self.get_market_data()
        recent_memory = await self.get_recent_memory()
        
        prompt = self.prompt_builder.build(
            market_data=market_data,
            account_state=account_state,
            permission_level=current_level,
            recent_memory=recent_memory
        )
        
        # 5. AI决策
        ai_decision = await self.call_deepseek(prompt)
        
        # 6. 应用指导性约束
        ai_decision = apply_confidence_threshold(ai_decision, current_level)
        ai_decision = apply_frequency_guidance(ai_decision, current_level, account_state["today_trades"])
        ai_decision = apply_position_size_guidance(ai_decision, current_level, account_state["balance"])
        
        # 7. 验证硬性约束
        if ai_decision["action"] in ["open_long", "open_short"]:
            is_valid, reason = await self.constraint_validator.validate(
                account_state, 
                ai_decision
            )
            
            if not is_valid:
                logger.warning(f"❌ 交易被硬约束拒绝: {reason}")
                ai_decision["status"] = "REJECTED"
                ai_decision["notes"] = reason
                return ai_decision
        
        # 8. 执行交易
        if ai_decision["status"] == "APPROVED":
            result = await self.execute_trade(ai_decision)
            
            # 9. 评估权限等级（交易后）
            await self.permission_manager.evaluate_and_update()
        
        return ai_decision
```

---

## 7. 测试验证

### 7.1 单元测试

```python
# tests/test_constraint_framework.py

import pytest

def test_permission_downgrade():
    """测试权限降级逻辑"""
    manager = PermissionManager(mock_db)
    
    # 模拟连续亏损
    performance = PerformanceData(
        consecutive_losses=5,
        max_drawdown=0.12,
        win_rate_7d=0.30
    )
    
    new_level, reason = manager._check_downgrade_triggers("L3", performance)
    
    assert new_level == "L0"
    assert "风控保护" in reason

def test_hard_constraints():
    """测试硬约束验证"""
    validator = ConstraintValidator()
    
    # 模拟账户状态
    account_state = {
        "margin_ratio": 0.18,  # 低于20%
        "total_drawdown": 0.08,
        "daily_loss": 0.03
    }
    
    proposed_trade = {
        "symbol": "BTC",
        "size_usd": 100,
        "leverage": 3
    }
    
    is_valid, reason = validator.validate(account_state, proposed_trade)
    
    assert not is_valid
    assert "保证金率不足" in reason
```

### 7.2 集成测试

**测试场景**：
1. ✅ L1权限下，AI尝试超出10%仓位 → 自动调整
2. ✅ 单日亏损达到5% → 触发强制平仓+降级L0
3. ✅ 连续7天50%+胜率 → 自动升级L1→L2
4. ✅ 置信度略低于门槛 → 减半仓位执行

---

## 8. 监控与优化

### 8.1 关键指标

```python
# 约束框架监控指标
CONSTRAINT_METRICS = {
    "权限等级分布": "各等级停留时间",
    "硬约束拒绝率": "被硬约束拦截的交易比例",
    "软约束调整率": "仓位/频率被调整的比例",
    "强制平仓次数": "触发强制平仓的次数",
    "权限升降频率": "升级和降级的频率"
}
```

### 8.2 持续优化

**Phase 1完成后评估**：
- 约束是否过松/过紧？
- 权限升降逻辑是否合理？
- AI是否能在约束下正常运作？

---

## 📚 相关文档

- [AI交易规则文档](../01-核心规则/AI交易规则文档.md) - 完整规则
- [记忆学习系统](./02-记忆学习系统.md) - 记忆系统技术细节
- [监控评估系统](./04-监控评估系统.md) - KPI指标体系

---

**文档版本**: v2.0  
**最后更新**: 2025-10-31  
**维护状态**: ✅ Active  
**Phase状态**: Phase 1核心实现

