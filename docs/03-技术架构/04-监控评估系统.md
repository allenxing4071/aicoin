# 📊 监控评估系统

> **来源**: 01-核心规则/AI交易规则文档.md 第六部分  
> **创建时间**: 2025-10-31  
> **版本**: v2.1  
> **状态**: Phase 1+ 技术文档

---

## 📋 目录

- [核心KPI指标体系](#核心kpi指标体系)
- [实时监控Dashboard](#实时监控dashboard)
- [告警系统设计](#告警系统设计)
- [性能分析工具](#性能分析工具)
- [报表生成](#报表生成)

---

## 🎯 核心KPI指标体系

### 交易性能指标（量化专业版）

```
┌─────────────────────────────────────────────────┐
│          核心交易指标（量化专业版）                 │
├─────────────────────────────────────────────────┤
│                                                 │
│  📊 盈利指标                                     │
│     • 总收益率 (Total Return)                   │
│     • 年化收益率 (APY)                          │
│     • 平均每笔PnL                                │
│     • 最大单笔盈利                               │
│     • 超额收益率 (Excess Return)                │
│                                                 │
│  🎯 风险指标                                     │
│     • 最大回撤 (Max Drawdown)                   │
│     • 最大回撤持续时间 (DD Duration)             │
│     • 当前回撤 (Current Drawdown)               │
│     • 年化波动率 (Annual Volatility)            │
│     • 下行波动率 (Downside Volatility)          │
│     • 跟踪误差 (Tracking Error)                 │
│                                                 │
│  📐 风险调整收益比率                             │
│     • 夏普比率 (Sharpe Ratio)                   │
│     • 索提诺比率 (Sortino Ratio)                │
│     • 信息比率 (Information Ratio)              │
│     • Calmar比率 (Calmar Ratio)                 │
│     • Omega比率 (Omega Ratio)                   │
│     • MAR比率 (Managed Account Ratio)           │
│                                                 │
│  ✅ 胜率指标                                     │
│     • 总体胜率 (Win Rate)                       │
│     • 7日/30日/90日胜率                          │
│     • 多头/空头胜率                              │
│     • 连胜/连亏次数                              │
│     • 盈利稳定性 (Profit Consistency)           │
│                                                 │
│  📈 效率指标                                     │
│     • 盈亏比 (Profit/Loss Ratio)                │
│     • 期望值 (Expectancy)                       │
│     • 凯利比例 (Kelly Criterion)                │
│     • 资金利用率                                 │
│     • 平均持仓时间                               │
│     • 交易频率                                   │
│     • 资金周转率 (Capital Turnover)             │
│                                                 │
└─────────────────────────────────────────────────┘
```

### KPI计算器实现

```python
# backend/app/services/kpi_calculator.py

from datetime import datetime, timedelta
import statistics
import math
from typing import List, Dict, Optional
import numpy as np

class KPICalculator:
    """
    KPI指标计算器
    提供所有关键量化指标的计算
    """
    
    def __init__(self, db_session):
        self.db = db_session
    
    async def calculate_all_kpis(
        self,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict:
        """
        计算所有KPI指标
        
        Args:
            start_date: 开始日期（默认：全部历史）
            end_date: 结束日期（默认：现在）
            
        Returns:
            完整的KPI指标字典
        """
        # 1. 获取交易数据
        trades = await self._get_trades(start_date, end_date)
        
        if not trades:
            return self._empty_kpis()
        
        # 2. 计算各类指标
        profitability = self._calc_profitability(trades)
        risk = self._calc_risk(trades)
        ratios = self._calc_ratios(trades)
        win_rate = self._calc_win_rate(trades)
        efficiency = self._calc_efficiency(trades)
        
        # 3. 组合返回
        return {
            "profitability": profitability,
            "risk": risk,
            "ratios": ratios,
            "win_rate": win_rate,
            "efficiency": efficiency,
            "metadata": {
                "total_trades": len(trades),
                "period_start": start_date.isoformat() if start_date else None,
                "period_end": end_date.isoformat() if end_date else None,
                "calculated_at": datetime.now().isoformat()
            }
        }
    
    def _calc_profitability(self, trades: List[Dict]) -> Dict:
        """
        计算盈利指标
        """
        pnls = [t["pnl"] for t in trades]
        initial_capital = 1000.0  # 初始资金
        
        total_return = sum(pnls)
        total_return_pct = total_return / initial_capital
        
        # 年化收益率
        days = (trades[-1]["closed_at"] - trades[0]["created_at"]).days
        apy = (1 + total_return_pct) ** (365 / days) - 1 if days > 0 else 0
        
        return {
            "total_return": total_return,
            "total_return_pct": total_return_pct,
            "annual_return": apy,
            "avg_pnl_per_trade": statistics.mean(pnls),
            "max_single_profit": max(pnls) if pnls else 0,
            "max_single_loss": min(pnls) if pnls else 0
        }
    
    def _calc_risk(self, trades: List[Dict]) -> Dict:
        """
        计算风险指标
        """
        pnls = [t["pnl"] for t in trades]
        
        # 最大回撤
        cumulative = np.cumsum(pnls)
        running_max = np.maximum.accumulate(cumulative)
        drawdowns = (running_max - cumulative) / (running_max + 1e-10)
        max_drawdown = np.max(drawdowns) if len(drawdowns) > 0 else 0
        
        # 当前回撤
        current_drawdown = drawdowns[-1] if len(drawdowns) > 0 else 0
        
        # 最大回撤持续时间
        max_dd_duration = self._calc_max_drawdown_duration(cumulative)
        
        # 年化波动率
        returns = np.array(pnls) / 1000.0  # 标准化
        annual_volatility = np.std(returns) * np.sqrt(252) if len(returns) > 1 else 0
        
        # 下行波动率（只考虑负收益）
        negative_returns = [r for r in returns if r < 0]
        downside_volatility = (
            np.std(negative_returns) * np.sqrt(252)
            if len(negative_returns) > 1
            else 0
        )
        
        return {
            "max_drawdown": max_drawdown,
            "max_drawdown_duration_days": max_dd_duration,
            "current_drawdown": current_drawdown,
            "annual_volatility": annual_volatility,
            "downside_volatility": downside_volatility,
            "var_95": np.percentile(pnls, 5) if pnls else 0,  # Value at Risk
            "cvar_95": np.mean([p for p in pnls if p < np.percentile(pnls, 5)]) if pnls else 0  # Conditional VaR
        }
    
    def _calc_ratios(self, trades: List[Dict]) -> Dict:
        """
        计算风险调整收益比率
        """
        pnls = [t["pnl"] for t in trades]
        
        # 计算收益率序列
        returns = np.array(pnls) / 1000.0
        
        # 夏普比率
        sharpe_ratio = (
            (np.mean(returns) / np.std(returns)) * np.sqrt(252)
            if len(returns) > 1 and np.std(returns) > 0
            else 0
        )
        
        # 索提诺比率（使用下行波动率）
        negative_returns = [r for r in returns if r < 0]
        downside_std = np.std(negative_returns) if len(negative_returns) > 1 else 1e-10
        sortino_ratio = (np.mean(returns) / downside_std) * np.sqrt(252)
        
        # Calmar比率（年化收益/最大回撤）
        annual_return = np.mean(returns) * 252
        cumulative = np.cumsum(pnls)
        running_max = np.maximum.accumulate(cumulative)
        drawdowns = (running_max - cumulative) / (running_max + 1e-10)
        max_drawdown = np.max(drawdowns) if len(drawdowns) > 0 else 1e-10
        calmar_ratio = annual_return / max_drawdown if max_drawdown > 0 else 0
        
        # Omega比率（收益/亏损的比例）
        gains = sum([p for p in pnls if p > 0])
        losses = abs(sum([p for p in pnls if p < 0]))
        omega_ratio = gains / losses if losses > 0 else 0
        
        # MAR比率（类似Calmar）
        mar_ratio = calmar_ratio
        
        return {
            "sharpe_ratio": sharpe_ratio,
            "sortino_ratio": sortino_ratio,
            "calmar_ratio": calmar_ratio,
            "omega_ratio": omega_ratio,
            "mar_ratio": mar_ratio
        }
    
    def _calc_win_rate(self, trades: List[Dict]) -> Dict:
        """
        计算胜率指标
        """
        total = len(trades)
        winning = sum(1 for t in trades if t["pnl"] > 0)
        
        # 总体胜率
        win_rate = winning / total if total > 0 else 0
        
        # 7日/30日/90日胜率
        now = datetime.now()
        win_rate_7d = self._calc_period_win_rate(trades, now - timedelta(days=7), now)
        win_rate_30d = self._calc_period_win_rate(trades, now - timedelta(days=30), now)
        win_rate_90d = self._calc_period_win_rate(trades, now - timedelta(days=90), now)
        
        # 多头/空头胜率
        long_trades = [t for t in trades if t.get("side") == "long"]
        short_trades = [t for t in trades if t.get("side") == "short"]
        
        long_win_rate = (
            sum(1 for t in long_trades if t["pnl"] > 0) / len(long_trades)
            if long_trades else 0
        )
        short_win_rate = (
            sum(1 for t in short_trades if t["pnl"] > 0) / len(short_trades)
            if short_trades else 0
        )
        
        # 连胜/连亏
        max_consecutive_wins, max_consecutive_losses = self._calc_consecutive_streaks(trades)
        
        # 盈利稳定性（胜率的标准差，越小越稳定）
        daily_win_rates = self._calc_daily_win_rates(trades)
        profit_consistency = 1 - np.std(daily_win_rates) if len(daily_win_rates) > 1 else 0
        
        return {
            "win_rate": win_rate,
            "win_rate_7d": win_rate_7d,
            "win_rate_30d": win_rate_30d,
            "win_rate_90d": win_rate_90d,
            "long_win_rate": long_win_rate,
            "short_win_rate": short_win_rate,
            "max_consecutive_wins": max_consecutive_wins,
            "max_consecutive_losses": max_consecutive_losses,
            "profit_consistency": profit_consistency
        }
    
    def _calc_efficiency(self, trades: List[Dict]) -> Dict:
        """
        计算效率指标
        """
        pnls = [t["pnl"] for t in trades]
        
        # 盈亏比
        avg_win = statistics.mean([p for p in pnls if p > 0]) if any(p > 0 for p in pnls) else 0
        avg_loss = abs(statistics.mean([p for p in pnls if p < 0])) if any(p < 0 for p in pnls) else 1
        profit_loss_ratio = avg_win / avg_loss if avg_loss > 0 else 0
        
        # 期望值（Expectancy）
        win_rate = sum(1 for p in pnls if p > 0) / len(pnls)
        expectancy = (win_rate * avg_win) - ((1 - win_rate) * avg_loss)
        
        # 凯利比例
        kelly_criterion = (
            (win_rate * profit_loss_ratio - (1 - win_rate)) / profit_loss_ratio
            if profit_loss_ratio > 0
            else 0
        )
        kelly_criterion = max(0, min(kelly_criterion, 0.25))  # 限制在0-25%
        
        # 平均持仓时间（小时）
        durations = [
            (t["closed_at"] - t["created_at"]).total_seconds() / 3600
            for t in trades
            if t.get("closed_at")
        ]
        avg_holding_time = statistics.mean(durations) if durations else 0
        
        # 交易频率（每天）
        days = (trades[-1]["closed_at"] - trades[0]["created_at"]).days or 1
        trades_per_day = len(trades) / days
        
        # 资金周转率
        total_volume = sum([t.get("size_usd", 0) for t in trades])
        capital_turnover = total_volume / 1000.0  # 相对初始资金
        
        return {
            "profit_loss_ratio": profit_loss_ratio,
            "expectancy": expectancy,
            "kelly_criterion": kelly_criterion,
            "avg_holding_time_hours": avg_holding_time,
            "trades_per_day": trades_per_day,
            "capital_turnover": capital_turnover
        }
    
    async def _get_trades(
        self,
        start_date: Optional[datetime],
        end_date: Optional[datetime]
    ) -> List[Dict]:
        """
        从数据库获取交易记录
        """
        query = """
            SELECT * FROM trades
            WHERE status = 'closed'
        """
        
        params = {}
        if start_date:
            query += " AND closed_at >= :start"
            params["start"] = start_date
        if end_date:
            query += " AND closed_at <= :end"
            params["end"] = end_date
        
        query += " ORDER BY closed_at ASC"
        
        result = await self.db.execute(query, params)
        return [dict(row) for row in result]
    
    def _calc_max_drawdown_duration(self, cumulative_pnl: np.ndarray) -> int:
        """
        计算最大回撤持续时间（天数）
        """
        if len(cumulative_pnl) == 0:
            return 0
        
        running_max = np.maximum.accumulate(cumulative_pnl)
        drawdown_start = None
        max_duration = 0
        current_duration = 0
        
        for i, (current, peak) in enumerate(zip(cumulative_pnl, running_max)):
            if current < peak:
                if drawdown_start is None:
                    drawdown_start = i
                current_duration = i - drawdown_start
                max_duration = max(max_duration, current_duration)
            else:
                drawdown_start = None
                current_duration = 0
        
        return max_duration
    
    def _calc_period_win_rate(
        self,
        trades: List[Dict],
        start: datetime,
        end: datetime
    ) -> float:
        """
        计算特定时间段的胜率
        """
        period_trades = [
            t for t in trades
            if start <= t["closed_at"] <= end
        ]
        
        if not period_trades:
            return 0
        
        winning = sum(1 for t in period_trades if t["pnl"] > 0)
        return winning / len(period_trades)
    
    def _calc_consecutive_streaks(self, trades: List[Dict]) -> tuple:
        """
        计算最大连胜和连亏次数
        """
        max_wins = 0
        max_losses = 0
        current_wins = 0
        current_losses = 0
        
        for trade in trades:
            if trade["pnl"] > 0:
                current_wins += 1
                current_losses = 0
                max_wins = max(max_wins, current_wins)
            else:
                current_losses += 1
                current_wins = 0
                max_losses = max(max_losses, current_losses)
        
        return max_wins, max_losses
    
    def _calc_daily_win_rates(self, trades: List[Dict]) -> List[float]:
        """
        计算每日胜率列表
        """
        from collections import defaultdict
        
        daily_trades = defaultdict(list)
        for trade in trades:
            day = trade["closed_at"].date()
            daily_trades[day].append(trade)
        
        daily_win_rates = []
        for day_trades in daily_trades.values():
            if len(day_trades) > 0:
                wins = sum(1 for t in day_trades if t["pnl"] > 0)
                daily_win_rates.append(wins / len(day_trades))
        
        return daily_win_rates
    
    def _empty_kpis(self) -> Dict:
        """
        返回空的KPI结构
        """
        return {
            "profitability": {},
            "risk": {},
            "ratios": {},
            "win_rate": {},
            "efficiency": {},
            "metadata": {
                "total_trades": 0,
                "message": "No trades in the specified period"
            }
        }
```

---

## 📺 实时监控Dashboard

### API接口设计

```python
# backend/app/api/v1/monitoring.py

from fastapi import APIRouter, Depends
from datetime import datetime, timedelta
from typing import Optional

router = APIRouter(prefix="/api/v1/monitoring", tags=["monitoring"])

@router.get("/kpis")
async def get_kpis(
    period: Optional[str] = "all",  # "7d", "30d", "90d", "all"
    db = Depends(get_db)
):
    """
    获取KPI指标
    
    Query Parameters:
        period: 时间周期
            - "7d": 最近7天
            - "30d": 最近30天
            - "90d": 最近90天
            - "all": 全部历史（默认）
    """
    calculator = KPICalculator(db)
    
    # 计算时间范围
    end_date = datetime.now()
    if period == "7d":
        start_date = end_date - timedelta(days=7)
    elif period == "30d":
        start_date = end_date - timedelta(days=30)
    elif period == "90d":
        start_date = end_date - timedelta(days=90)
    else:
        start_date = None
    
    # 计算KPIs
    kpis = await calculator.calculate_all_kpis(start_date, end_date)
    
    return {
        "success": True,
        "data": kpis
    }

@router.get("/realtime")
async def get_realtime_status(
    redis = Depends(get_redis),
    db = Depends(get_db)
):
    """
    获取实时状态
    
    Returns:
        - 当前账户状态
        - 持仓信息
        - 今日统计
        - 系统状态
    """
    # 1. 账户状态
    # 2. 持仓信息
    # 3. 今日交易统计
    # 4. 系统健康状态
    
    return {
        "success": True,
        "data": {
            "account": {},
            "positions": [],
            "today_stats": {},
            "system_health": {}
        }
    }

@router.get("/equity_curve")
async def get_equity_curve(
    period: Optional[str] = "30d",
    db = Depends(get_db)
):
    """
    获取权益曲线数据
    
    Returns:
        时间序列数据，用于绘制权益曲线图
    """
    # 获取历史交易
    # 计算累计PnL
    # 返回时间序列
    
    return {
        "success": True,
        "data": {
            "timestamps": [],
            "equity": [],
            "drawdown": []
        }
    }
```

---

## 🚨 告警系统设计

### 告警规则配置

```python
# backend/app/services/alert_manager.py

from enum import Enum
from typing import List, Callable
import logging

logger = logging.getLogger(__name__)

class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"

class AlertRule:
    """
    告警规则定义
    """
    def __init__(
        self,
        name: str,
        description: str,
        level: AlertLevel,
        condition: Callable,
        cooldown_minutes: int = 60
    ):
        self.name = name
        self.description = description
        self.level = level
        self.condition = condition
        self.cooldown_minutes = cooldown_minutes
        self.last_triggered = None

class AlertManager:
    """
    告警管理器
    """
    
    def __init__(self, db_session, notification_service):
        self.db = db_session
        self.notifier = notification_service
        self.rules = self._init_rules()
    
    def _init_rules(self) -> List[AlertRule]:
        """
        初始化告警规则
        """
        return [
            # 🔴 关键告警
            AlertRule(
                name="large_loss",
                description="单笔亏损超过5%",
                level=AlertLevel.CRITICAL,
                condition=lambda data: data.get("loss_pct", 0) > 0.05,
                cooldown_minutes=30
            ),
            
            AlertRule(
                name="daily_loss_limit",
                description="单日亏损超过10%",
                level=AlertLevel.CRITICAL,
                condition=lambda data: data.get("daily_loss_pct", 0) > 0.10,
                cooldown_minutes=120
            ),
            
            AlertRule(
                name="max_drawdown_exceeded",
                description="最大回撤超过15%",
                level=AlertLevel.CRITICAL,
                condition=lambda data: data.get("max_drawdown", 0) > 0.15,
                cooldown_minutes=240
            ),
            
            # ⚠️ 警告告警
            AlertRule(
                name="win_rate_drop",
                description="7日胜率低于40%",
                level=AlertLevel.WARNING,
                condition=lambda data: data.get("win_rate_7d", 1) < 0.40,
                cooldown_minutes=360
            ),
            
            AlertRule(
                name="consecutive_losses",
                description="连续亏损3次",
                level=AlertLevel.WARNING,
                condition=lambda data: data.get("consecutive_losses", 0) >= 3,
                cooldown_minutes=60
            ),
            
            # ℹ️ 信息告警
            AlertRule(
                name="permission_upgraded",
                description="权限等级提升",
                level=AlertLevel.INFO,
                condition=lambda data: data.get("permission_changed", False) and data.get("permission_direction") == "up",
                cooldown_minutes=0
            )
        ]
    
    async def check_alerts(self, data: dict) -> List[dict]:
        """
        检查所有告警规则
        
        Args:
            data: 当前系统数据
            
        Returns:
            触发的告警列表
        """
        triggered_alerts = []
        
        for rule in self.rules:
            # 检查冷却期
            if self._is_in_cooldown(rule):
                continue
            
            # 检查条件
            try:
                if rule.condition(data):
                    alert = await self._trigger_alert(rule, data)
                    triggered_alerts.append(alert)
            except Exception as e:
                logger.error(f"告警规则检查失败: {rule.name} - {e}")
        
        return triggered_alerts
    
    async def _trigger_alert(self, rule: AlertRule, data: dict) -> dict:
        """
        触发告警
        """
        alert = {
            "name": rule.name,
            "description": rule.description,
            "level": rule.level.value,
            "data": data,
            "triggered_at": datetime.now().isoformat()
        }
        
        # 记录到数据库
        await self._save_alert(alert)
        
        # 发送通知
        await self.notifier.send(alert)
        
        # 更新最后触发时间
        rule.last_triggered = datetime.now()
        
        logger.warning(f"🚨 告警触发: {rule.name} - {rule.description}")
        
        return alert
    
    def _is_in_cooldown(self, rule: AlertRule) -> bool:
        """
        检查是否在冷却期内
        """
        if rule.last_triggered is None:
            return False
        
        cooldown_delta = timedelta(minutes=rule.cooldown_minutes)
        return datetime.now() - rule.last_triggered < cooldown_delta
    
    async def _save_alert(self, alert: dict):
        """
        保存告警到数据库
        """
        await self.db.execute(
            """
            INSERT INTO alerts (name, description, level, data, triggered_at)
            VALUES (:name, :desc, :level, :data, NOW())
            """,
            {
                "name": alert["name"],
                "desc": alert["description"],
                "level": alert["level"],
                "data": json.dumps(alert["data"])
            }
        )
        await self.db.commit()
```

---

## 📈 性能分析工具

### 回测分析

```python
# backend/app/services/backtest_analyzer.py

class BacktestAnalyzer:
    """
    回测分析工具
    分析历史交易，生成性能报告
    """
    
    def __init__(self, db_session):
        self.db = db_session
        self.kpi_calc = KPICalculator(db_session)
    
    async def analyze_period(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        分析特定时间段的表现
        """
        # 1. 计算KPIs
        kpis = await self.kpi_calc.calculate_all_kpis(start_date, end_date)
        
        # 2. 生成权益曲线
        equity_curve = await self._generate_equity_curve(start_date, end_date)
        
        # 3. 分析交易分布
        trade_distribution = await self._analyze_trade_distribution(start_date, end_date)
        
        # 4. 识别最佳/最差交易
        best_worst = await self._identify_best_worst_trades(start_date, end_date)
        
        return {
            "kpis": kpis,
            "equity_curve": equity_curve,
            "trade_distribution": trade_distribution,
            "best_worst": best_worst,
            "period": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat()
            }
        }
    
    async def _generate_equity_curve(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        生成权益曲线数据
        """
        trades = await self.kpi_calc._get_trades(start_date, end_date)
        
        timestamps = []
        equity = []
        cumulative_pnl = 1000.0  # 初始资金
        
        for trade in trades:
            timestamps.append(trade["closed_at"].isoformat())
            cumulative_pnl += trade["pnl"]
            equity.append(cumulative_pnl)
        
        return {
            "timestamps": timestamps,
            "equity": equity
        }
    
    async def _analyze_trade_distribution(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        分析交易分布
        """
        trades = await self.kpi_calc._get_trades(start_date, end_date)
        
        # 按币种统计
        by_symbol = {}
        # 按方向统计
        by_side = {"long": 0, "short": 0}
        # 按时段统计
        by_hour = {i: 0 for i in range(24)}
        
        for trade in trades:
            symbol = trade.get("symbol", "unknown")
            by_symbol[symbol] = by_symbol.get(symbol, 0) + 1
            
            side = trade.get("side", "long")
            by_side[side] += 1
            
            hour = trade["created_at"].hour
            by_hour[hour] += 1
        
        return {
            "by_symbol": by_symbol,
            "by_side": by_side,
            "by_hour": by_hour
        }
    
    async def _identify_best_worst_trades(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        识别最佳和最差交易
        """
        trades = await self.kpi_calc._get_trades(start_date, end_date)
        
        # 排序
        sorted_trades = sorted(trades, key=lambda t: t["pnl"], reverse=True)
        
        return {
            "best_5": sorted_trades[:5],
            "worst_5": sorted_trades[-5:]
        }
```

---

## 📄 报表生成

### 每日报告

```python
# backend/app/tasks/daily_report.py

from celery import Celery

celery = Celery("ai_trading")

@celery.task
async def generate_daily_report():
    """
    生成每日报告
    触发时间: 每天 UTC 00:30
    """
    today = datetime.now().date()
    yesterday = today - timedelta(days=1)
    
    # 1. 计算昨日KPIs
    analyzer = BacktestAnalyzer(db)
    report = await analyzer.analyze_period(
        start_date=datetime.combine(yesterday, datetime.min.time()),
        end_date=datetime.combine(yesterday, datetime.max.time())
    )
    
    # 2. 生成报告内容
    report_text = f"""
# AI交易系统每日报告
日期: {yesterday}

## 📊 关键指标
- 总交易次数: {report['kpis']['metadata']['total_trades']}
- 胜率: {report['kpis']['win_rate']['win_rate']:.1%}
- 总PnL: ${report['kpis']['profitability']['total_return']:.2f}
- 夏普比率: {report['kpis']['ratios']['sharpe_ratio']:.2f}

## 🎯 风险指标
- 最大回撤: {report['kpis']['risk']['max_drawdown']:.1%}
- 波动率: {report['kpis']['risk']['annual_volatility']:.2f}

## 💡 关键洞察
{_generate_insights(report)}

---
*由AI交易系统自动生成*
    """
    
    # 3. 发送报告
    await send_report(report_text)
    
    logger.info(f"✅ 每日报告已生成: {yesterday}")

def _generate_insights(report: dict) -> str:
    """
    生成关键洞察
    """
    insights = []
    
    kpis = report['kpis']
    
    if kpis['win_rate']['win_rate'] > 0.6:
        insights.append("✅ 胜率表现优秀")
    elif kpis['win_rate']['win_rate'] < 0.4:
        insights.append("⚠️ 胜率偏低，需要调整策略")
    
    if kpis['profitability']['total_return'] > 0:
        insights.append("✅ 实现盈利")
    else:
        insights.append("⚠️ 出现亏损")
    
    return "\n".join(insights) if insights else "无特殊情况"
```

---

**文档状态**: ✅ 完成  
**适用阶段**: Phase 1+（所有阶段）  
**最后更新**: 2025-10-31

---

*本文档提供完整的监控评估系统设计方案。建议在Phase 1即开始实施基础监控，随着项目发展逐步完善。*

