# ğŸ“Š ç›‘æ§è¯„ä¼°ç³»ç»Ÿ

> **æ¥æº**: 01-æ ¸å¿ƒè§„åˆ™/AIäº¤æ˜“è§„åˆ™æ–‡æ¡£.md ç¬¬å…­éƒ¨åˆ†  
> **åˆ›å»ºæ—¶é—´**: 2025-10-31  
> **ç‰ˆæœ¬**: v2.1  
> **çŠ¶æ€**: Phase 1+ æŠ€æœ¯æ–‡æ¡£

---

## ğŸ“‹ ç›®å½•

- [æ ¸å¿ƒKPIæŒ‡æ ‡ä½“ç³»](#æ ¸å¿ƒkpiæŒ‡æ ‡ä½“ç³»)
- [å®æ—¶ç›‘æ§Dashboard](#å®æ—¶ç›‘æ§dashboard)
- [å‘Šè­¦ç³»ç»Ÿè®¾è®¡](#å‘Šè­¦ç³»ç»Ÿè®¾è®¡)
- [æ€§èƒ½åˆ†æå·¥å…·](#æ€§èƒ½åˆ†æå·¥å…·)
- [æŠ¥è¡¨ç”Ÿæˆ](#æŠ¥è¡¨ç”Ÿæˆ)

---

## ğŸ¯ æ ¸å¿ƒKPIæŒ‡æ ‡ä½“ç³»

### äº¤æ˜“æ€§èƒ½æŒ‡æ ‡ï¼ˆé‡åŒ–ä¸“ä¸šç‰ˆï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          æ ¸å¿ƒäº¤æ˜“æŒ‡æ ‡ï¼ˆé‡åŒ–ä¸“ä¸šç‰ˆï¼‰                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ğŸ“Š ç›ˆåˆ©æŒ‡æ ‡                                     â”‚
â”‚     â€¢ æ€»æ”¶ç›Šç‡ (Total Return)                   â”‚
â”‚     â€¢ å¹´åŒ–æ”¶ç›Šç‡ (APY)                          â”‚
â”‚     â€¢ å¹³å‡æ¯ç¬”PnL                                â”‚
â”‚     â€¢ æœ€å¤§å•ç¬”ç›ˆåˆ©                               â”‚
â”‚     â€¢ è¶…é¢æ”¶ç›Šç‡ (Excess Return)                â”‚
â”‚                                                 â”‚
â”‚  ğŸ¯ é£é™©æŒ‡æ ‡                                     â”‚
â”‚     â€¢ æœ€å¤§å›æ’¤ (Max Drawdown)                   â”‚
â”‚     â€¢ æœ€å¤§å›æ’¤æŒç»­æ—¶é—´ (DD Duration)             â”‚
â”‚     â€¢ å½“å‰å›æ’¤ (Current Drawdown)               â”‚
â”‚     â€¢ å¹´åŒ–æ³¢åŠ¨ç‡ (Annual Volatility)            â”‚
â”‚     â€¢ ä¸‹è¡Œæ³¢åŠ¨ç‡ (Downside Volatility)          â”‚
â”‚     â€¢ è·Ÿè¸ªè¯¯å·® (Tracking Error)                 â”‚
â”‚                                                 â”‚
â”‚  ğŸ“ é£é™©è°ƒæ•´æ”¶ç›Šæ¯”ç‡                             â”‚
â”‚     â€¢ å¤æ™®æ¯”ç‡ (Sharpe Ratio)                   â”‚
â”‚     â€¢ ç´¢æè¯ºæ¯”ç‡ (Sortino Ratio)                â”‚
â”‚     â€¢ ä¿¡æ¯æ¯”ç‡ (Information Ratio)              â”‚
â”‚     â€¢ Calmaræ¯”ç‡ (Calmar Ratio)                 â”‚
â”‚     â€¢ Omegaæ¯”ç‡ (Omega Ratio)                   â”‚
â”‚     â€¢ MARæ¯”ç‡ (Managed Account Ratio)           â”‚
â”‚                                                 â”‚
â”‚  âœ… èƒœç‡æŒ‡æ ‡                                     â”‚
â”‚     â€¢ æ€»ä½“èƒœç‡ (Win Rate)                       â”‚
â”‚     â€¢ 7æ—¥/30æ—¥/90æ—¥èƒœç‡                          â”‚
â”‚     â€¢ å¤šå¤´/ç©ºå¤´èƒœç‡                              â”‚
â”‚     â€¢ è¿èƒœ/è¿äºæ¬¡æ•°                              â”‚
â”‚     â€¢ ç›ˆåˆ©ç¨³å®šæ€§ (Profit Consistency)           â”‚
â”‚                                                 â”‚
â”‚  ğŸ“ˆ æ•ˆç‡æŒ‡æ ‡                                     â”‚
â”‚     â€¢ ç›ˆäºæ¯” (Profit/Loss Ratio)                â”‚
â”‚     â€¢ æœŸæœ›å€¼ (Expectancy)                       â”‚
â”‚     â€¢ å‡¯åˆ©æ¯”ä¾‹ (Kelly Criterion)                â”‚
â”‚     â€¢ èµ„é‡‘åˆ©ç”¨ç‡                                 â”‚
â”‚     â€¢ å¹³å‡æŒä»“æ—¶é—´                               â”‚
â”‚     â€¢ äº¤æ˜“é¢‘ç‡                                   â”‚
â”‚     â€¢ èµ„é‡‘å‘¨è½¬ç‡ (Capital Turnover)             â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### KPIè®¡ç®—å™¨å®ç°

```python
# backend/app/services/kpi_calculator.py

from datetime import datetime, timedelta
import statistics
import math
from typing import List, Dict, Optional
import numpy as np

class KPICalculator:
    """
    KPIæŒ‡æ ‡è®¡ç®—å™¨
    æä¾›æ‰€æœ‰å…³é”®é‡åŒ–æŒ‡æ ‡çš„è®¡ç®—
    """
    
    def __init__(self, db_session):
        self.db = db_session
    
    async def calculate_all_kpis(
        self,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict:
        """
        è®¡ç®—æ‰€æœ‰KPIæŒ‡æ ‡
        
        Args:
            start_date: å¼€å§‹æ—¥æœŸï¼ˆé»˜è®¤ï¼šå…¨éƒ¨å†å²ï¼‰
            end_date: ç»“æŸæ—¥æœŸï¼ˆé»˜è®¤ï¼šç°åœ¨ï¼‰
            
        Returns:
            å®Œæ•´çš„KPIæŒ‡æ ‡å­—å…¸
        """
        # 1. è·å–äº¤æ˜“æ•°æ®
        trades = await self._get_trades(start_date, end_date)
        
        if not trades:
            return self._empty_kpis()
        
        # 2. è®¡ç®—å„ç±»æŒ‡æ ‡
        profitability = self._calc_profitability(trades)
        risk = self._calc_risk(trades)
        ratios = self._calc_ratios(trades)
        win_rate = self._calc_win_rate(trades)
        efficiency = self._calc_efficiency(trades)
        
        # 3. ç»„åˆè¿”å›
        return {
            "profitability": profitability,
            "risk": risk,
            "ratios": ratios,
            "win_rate": win_rate,
            "efficiency": efficiency,
            "metadata": {
                "total_trades": len(trades),
                "period_start": start_date.isoformat() if start_date else None,
                "period_end": end_date.isoformat() if end_date else None,
                "calculated_at": datetime.now().isoformat()
            }
        }
    
    def _calc_profitability(self, trades: List[Dict]) -> Dict:
        """
        è®¡ç®—ç›ˆåˆ©æŒ‡æ ‡
        """
        pnls = [t["pnl"] for t in trades]
        initial_capital = 1000.0  # åˆå§‹èµ„é‡‘
        
        total_return = sum(pnls)
        total_return_pct = total_return / initial_capital
        
        # å¹´åŒ–æ”¶ç›Šç‡
        days = (trades[-1]["closed_at"] - trades[0]["created_at"]).days
        apy = (1 + total_return_pct) ** (365 / days) - 1 if days > 0 else 0
        
        return {
            "total_return": total_return,
            "total_return_pct": total_return_pct,
            "annual_return": apy,
            "avg_pnl_per_trade": statistics.mean(pnls),
            "max_single_profit": max(pnls) if pnls else 0,
            "max_single_loss": min(pnls) if pnls else 0
        }
    
    def _calc_risk(self, trades: List[Dict]) -> Dict:
        """
        è®¡ç®—é£é™©æŒ‡æ ‡
        """
        pnls = [t["pnl"] for t in trades]
        
        # æœ€å¤§å›æ’¤
        cumulative = np.cumsum(pnls)
        running_max = np.maximum.accumulate(cumulative)
        drawdowns = (running_max - cumulative) / (running_max + 1e-10)
        max_drawdown = np.max(drawdowns) if len(drawdowns) > 0 else 0
        
        # å½“å‰å›æ’¤
        current_drawdown = drawdowns[-1] if len(drawdowns) > 0 else 0
        
        # æœ€å¤§å›æ’¤æŒç»­æ—¶é—´
        max_dd_duration = self._calc_max_drawdown_duration(cumulative)
        
        # å¹´åŒ–æ³¢åŠ¨ç‡
        returns = np.array(pnls) / 1000.0  # æ ‡å‡†åŒ–
        annual_volatility = np.std(returns) * np.sqrt(252) if len(returns) > 1 else 0
        
        # ä¸‹è¡Œæ³¢åŠ¨ç‡ï¼ˆåªè€ƒè™‘è´Ÿæ”¶ç›Šï¼‰
        negative_returns = [r for r in returns if r < 0]
        downside_volatility = (
            np.std(negative_returns) * np.sqrt(252)
            if len(negative_returns) > 1
            else 0
        )
        
        return {
            "max_drawdown": max_drawdown,
            "max_drawdown_duration_days": max_dd_duration,
            "current_drawdown": current_drawdown,
            "annual_volatility": annual_volatility,
            "downside_volatility": downside_volatility,
            "var_95": np.percentile(pnls, 5) if pnls else 0,  # Value at Risk
            "cvar_95": np.mean([p for p in pnls if p < np.percentile(pnls, 5)]) if pnls else 0  # Conditional VaR
        }
    
    def _calc_ratios(self, trades: List[Dict]) -> Dict:
        """
        è®¡ç®—é£é™©è°ƒæ•´æ”¶ç›Šæ¯”ç‡
        """
        pnls = [t["pnl"] for t in trades]
        
        # è®¡ç®—æ”¶ç›Šç‡åºåˆ—
        returns = np.array(pnls) / 1000.0
        
        # å¤æ™®æ¯”ç‡
        sharpe_ratio = (
            (np.mean(returns) / np.std(returns)) * np.sqrt(252)
            if len(returns) > 1 and np.std(returns) > 0
            else 0
        )
        
        # ç´¢æè¯ºæ¯”ç‡ï¼ˆä½¿ç”¨ä¸‹è¡Œæ³¢åŠ¨ç‡ï¼‰
        negative_returns = [r for r in returns if r < 0]
        downside_std = np.std(negative_returns) if len(negative_returns) > 1 else 1e-10
        sortino_ratio = (np.mean(returns) / downside_std) * np.sqrt(252)
        
        # Calmaræ¯”ç‡ï¼ˆå¹´åŒ–æ”¶ç›Š/æœ€å¤§å›æ’¤ï¼‰
        annual_return = np.mean(returns) * 252
        cumulative = np.cumsum(pnls)
        running_max = np.maximum.accumulate(cumulative)
        drawdowns = (running_max - cumulative) / (running_max + 1e-10)
        max_drawdown = np.max(drawdowns) if len(drawdowns) > 0 else 1e-10
        calmar_ratio = annual_return / max_drawdown if max_drawdown > 0 else 0
        
        # Omegaæ¯”ç‡ï¼ˆæ”¶ç›Š/äºæŸçš„æ¯”ä¾‹ï¼‰
        gains = sum([p for p in pnls if p > 0])
        losses = abs(sum([p for p in pnls if p < 0]))
        omega_ratio = gains / losses if losses > 0 else 0
        
        # MARæ¯”ç‡ï¼ˆç±»ä¼¼Calmarï¼‰
        mar_ratio = calmar_ratio
        
        return {
            "sharpe_ratio": sharpe_ratio,
            "sortino_ratio": sortino_ratio,
            "calmar_ratio": calmar_ratio,
            "omega_ratio": omega_ratio,
            "mar_ratio": mar_ratio
        }
    
    def _calc_win_rate(self, trades: List[Dict]) -> Dict:
        """
        è®¡ç®—èƒœç‡æŒ‡æ ‡
        """
        total = len(trades)
        winning = sum(1 for t in trades if t["pnl"] > 0)
        
        # æ€»ä½“èƒœç‡
        win_rate = winning / total if total > 0 else 0
        
        # 7æ—¥/30æ—¥/90æ—¥èƒœç‡
        now = datetime.now()
        win_rate_7d = self._calc_period_win_rate(trades, now - timedelta(days=7), now)
        win_rate_30d = self._calc_period_win_rate(trades, now - timedelta(days=30), now)
        win_rate_90d = self._calc_period_win_rate(trades, now - timedelta(days=90), now)
        
        # å¤šå¤´/ç©ºå¤´èƒœç‡
        long_trades = [t for t in trades if t.get("side") == "long"]
        short_trades = [t for t in trades if t.get("side") == "short"]
        
        long_win_rate = (
            sum(1 for t in long_trades if t["pnl"] > 0) / len(long_trades)
            if long_trades else 0
        )
        short_win_rate = (
            sum(1 for t in short_trades if t["pnl"] > 0) / len(short_trades)
            if short_trades else 0
        )
        
        # è¿èƒœ/è¿äº
        max_consecutive_wins, max_consecutive_losses = self._calc_consecutive_streaks(trades)
        
        # ç›ˆåˆ©ç¨³å®šæ€§ï¼ˆèƒœç‡çš„æ ‡å‡†å·®ï¼Œè¶Šå°è¶Šç¨³å®šï¼‰
        daily_win_rates = self._calc_daily_win_rates(trades)
        profit_consistency = 1 - np.std(daily_win_rates) if len(daily_win_rates) > 1 else 0
        
        return {
            "win_rate": win_rate,
            "win_rate_7d": win_rate_7d,
            "win_rate_30d": win_rate_30d,
            "win_rate_90d": win_rate_90d,
            "long_win_rate": long_win_rate,
            "short_win_rate": short_win_rate,
            "max_consecutive_wins": max_consecutive_wins,
            "max_consecutive_losses": max_consecutive_losses,
            "profit_consistency": profit_consistency
        }
    
    def _calc_efficiency(self, trades: List[Dict]) -> Dict:
        """
        è®¡ç®—æ•ˆç‡æŒ‡æ ‡
        """
        pnls = [t["pnl"] for t in trades]
        
        # ç›ˆäºæ¯”
        avg_win = statistics.mean([p for p in pnls if p > 0]) if any(p > 0 for p in pnls) else 0
        avg_loss = abs(statistics.mean([p for p in pnls if p < 0])) if any(p < 0 for p in pnls) else 1
        profit_loss_ratio = avg_win / avg_loss if avg_loss > 0 else 0
        
        # æœŸæœ›å€¼ï¼ˆExpectancyï¼‰
        win_rate = sum(1 for p in pnls if p > 0) / len(pnls)
        expectancy = (win_rate * avg_win) - ((1 - win_rate) * avg_loss)
        
        # å‡¯åˆ©æ¯”ä¾‹
        kelly_criterion = (
            (win_rate * profit_loss_ratio - (1 - win_rate)) / profit_loss_ratio
            if profit_loss_ratio > 0
            else 0
        )
        kelly_criterion = max(0, min(kelly_criterion, 0.25))  # é™åˆ¶åœ¨0-25%
        
        # å¹³å‡æŒä»“æ—¶é—´ï¼ˆå°æ—¶ï¼‰
        durations = [
            (t["closed_at"] - t["created_at"]).total_seconds() / 3600
            for t in trades
            if t.get("closed_at")
        ]
        avg_holding_time = statistics.mean(durations) if durations else 0
        
        # äº¤æ˜“é¢‘ç‡ï¼ˆæ¯å¤©ï¼‰
        days = (trades[-1]["closed_at"] - trades[0]["created_at"]).days or 1
        trades_per_day = len(trades) / days
        
        # èµ„é‡‘å‘¨è½¬ç‡
        total_volume = sum([t.get("size_usd", 0) for t in trades])
        capital_turnover = total_volume / 1000.0  # ç›¸å¯¹åˆå§‹èµ„é‡‘
        
        return {
            "profit_loss_ratio": profit_loss_ratio,
            "expectancy": expectancy,
            "kelly_criterion": kelly_criterion,
            "avg_holding_time_hours": avg_holding_time,
            "trades_per_day": trades_per_day,
            "capital_turnover": capital_turnover
        }
    
    async def _get_trades(
        self,
        start_date: Optional[datetime],
        end_date: Optional[datetime]
    ) -> List[Dict]:
        """
        ä»æ•°æ®åº“è·å–äº¤æ˜“è®°å½•
        """
        query = """
            SELECT * FROM trades
            WHERE status = 'closed'
        """
        
        params = {}
        if start_date:
            query += " AND closed_at >= :start"
            params["start"] = start_date
        if end_date:
            query += " AND closed_at <= :end"
            params["end"] = end_date
        
        query += " ORDER BY closed_at ASC"
        
        result = await self.db.execute(query, params)
        return [dict(row) for row in result]
    
    def _calc_max_drawdown_duration(self, cumulative_pnl: np.ndarray) -> int:
        """
        è®¡ç®—æœ€å¤§å›æ’¤æŒç»­æ—¶é—´ï¼ˆå¤©æ•°ï¼‰
        """
        if len(cumulative_pnl) == 0:
            return 0
        
        running_max = np.maximum.accumulate(cumulative_pnl)
        drawdown_start = None
        max_duration = 0
        current_duration = 0
        
        for i, (current, peak) in enumerate(zip(cumulative_pnl, running_max)):
            if current < peak:
                if drawdown_start is None:
                    drawdown_start = i
                current_duration = i - drawdown_start
                max_duration = max(max_duration, current_duration)
            else:
                drawdown_start = None
                current_duration = 0
        
        return max_duration
    
    def _calc_period_win_rate(
        self,
        trades: List[Dict],
        start: datetime,
        end: datetime
    ) -> float:
        """
        è®¡ç®—ç‰¹å®šæ—¶é—´æ®µçš„èƒœç‡
        """
        period_trades = [
            t for t in trades
            if start <= t["closed_at"] <= end
        ]
        
        if not period_trades:
            return 0
        
        winning = sum(1 for t in period_trades if t["pnl"] > 0)
        return winning / len(period_trades)
    
    def _calc_consecutive_streaks(self, trades: List[Dict]) -> tuple:
        """
        è®¡ç®—æœ€å¤§è¿èƒœå’Œè¿äºæ¬¡æ•°
        """
        max_wins = 0
        max_losses = 0
        current_wins = 0
        current_losses = 0
        
        for trade in trades:
            if trade["pnl"] > 0:
                current_wins += 1
                current_losses = 0
                max_wins = max(max_wins, current_wins)
            else:
                current_losses += 1
                current_wins = 0
                max_losses = max(max_losses, current_losses)
        
        return max_wins, max_losses
    
    def _calc_daily_win_rates(self, trades: List[Dict]) -> List[float]:
        """
        è®¡ç®—æ¯æ—¥èƒœç‡åˆ—è¡¨
        """
        from collections import defaultdict
        
        daily_trades = defaultdict(list)
        for trade in trades:
            day = trade["closed_at"].date()
            daily_trades[day].append(trade)
        
        daily_win_rates = []
        for day_trades in daily_trades.values():
            if len(day_trades) > 0:
                wins = sum(1 for t in day_trades if t["pnl"] > 0)
                daily_win_rates.append(wins / len(day_trades))
        
        return daily_win_rates
    
    def _empty_kpis(self) -> Dict:
        """
        è¿”å›ç©ºçš„KPIç»“æ„
        """
        return {
            "profitability": {},
            "risk": {},
            "ratios": {},
            "win_rate": {},
            "efficiency": {},
            "metadata": {
                "total_trades": 0,
                "message": "No trades in the specified period"
            }
        }
```

---

## ğŸ“º å®æ—¶ç›‘æ§Dashboard

### APIæ¥å£è®¾è®¡

```python
# backend/app/api/v1/monitoring.py

from fastapi import APIRouter, Depends
from datetime import datetime, timedelta
from typing import Optional

router = APIRouter(prefix="/api/v1/monitoring", tags=["monitoring"])

@router.get("/kpis")
async def get_kpis(
    period: Optional[str] = "all",  # "7d", "30d", "90d", "all"
    db = Depends(get_db)
):
    """
    è·å–KPIæŒ‡æ ‡
    
    Query Parameters:
        period: æ—¶é—´å‘¨æœŸ
            - "7d": æœ€è¿‘7å¤©
            - "30d": æœ€è¿‘30å¤©
            - "90d": æœ€è¿‘90å¤©
            - "all": å…¨éƒ¨å†å²ï¼ˆé»˜è®¤ï¼‰
    """
    calculator = KPICalculator(db)
    
    # è®¡ç®—æ—¶é—´èŒƒå›´
    end_date = datetime.now()
    if period == "7d":
        start_date = end_date - timedelta(days=7)
    elif period == "30d":
        start_date = end_date - timedelta(days=30)
    elif period == "90d":
        start_date = end_date - timedelta(days=90)
    else:
        start_date = None
    
    # è®¡ç®—KPIs
    kpis = await calculator.calculate_all_kpis(start_date, end_date)
    
    return {
        "success": True,
        "data": kpis
    }

@router.get("/realtime")
async def get_realtime_status(
    redis = Depends(get_redis),
    db = Depends(get_db)
):
    """
    è·å–å®æ—¶çŠ¶æ€
    
    Returns:
        - å½“å‰è´¦æˆ·çŠ¶æ€
        - æŒä»“ä¿¡æ¯
        - ä»Šæ—¥ç»Ÿè®¡
        - ç³»ç»ŸçŠ¶æ€
    """
    # 1. è´¦æˆ·çŠ¶æ€
    # 2. æŒä»“ä¿¡æ¯
    # 3. ä»Šæ—¥äº¤æ˜“ç»Ÿè®¡
    # 4. ç³»ç»Ÿå¥åº·çŠ¶æ€
    
    return {
        "success": True,
        "data": {
            "account": {},
            "positions": [],
            "today_stats": {},
            "system_health": {}
        }
    }

@router.get("/equity_curve")
async def get_equity_curve(
    period: Optional[str] = "30d",
    db = Depends(get_db)
):
    """
    è·å–æƒç›Šæ›²çº¿æ•°æ®
    
    Returns:
        æ—¶é—´åºåˆ—æ•°æ®ï¼Œç”¨äºç»˜åˆ¶æƒç›Šæ›²çº¿å›¾
    """
    # è·å–å†å²äº¤æ˜“
    # è®¡ç®—ç´¯è®¡PnL
    # è¿”å›æ—¶é—´åºåˆ—
    
    return {
        "success": True,
        "data": {
            "timestamps": [],
            "equity": [],
            "drawdown": []
        }
    }
```

---

## ğŸš¨ å‘Šè­¦ç³»ç»Ÿè®¾è®¡

### å‘Šè­¦è§„åˆ™é…ç½®

```python
# backend/app/services/alert_manager.py

from enum import Enum
from typing import List, Callable
import logging

logger = logging.getLogger(__name__)

class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"

class AlertRule:
    """
    å‘Šè­¦è§„åˆ™å®šä¹‰
    """
    def __init__(
        self,
        name: str,
        description: str,
        level: AlertLevel,
        condition: Callable,
        cooldown_minutes: int = 60
    ):
        self.name = name
        self.description = description
        self.level = level
        self.condition = condition
        self.cooldown_minutes = cooldown_minutes
        self.last_triggered = None

class AlertManager:
    """
    å‘Šè­¦ç®¡ç†å™¨
    """
    
    def __init__(self, db_session, notification_service):
        self.db = db_session
        self.notifier = notification_service
        self.rules = self._init_rules()
    
    def _init_rules(self) -> List[AlertRule]:
        """
        åˆå§‹åŒ–å‘Šè­¦è§„åˆ™
        """
        return [
            # ğŸ”´ å…³é”®å‘Šè­¦
            AlertRule(
                name="large_loss",
                description="å•ç¬”äºæŸè¶…è¿‡5%",
                level=AlertLevel.CRITICAL,
                condition=lambda data: data.get("loss_pct", 0) > 0.05,
                cooldown_minutes=30
            ),
            
            AlertRule(
                name="daily_loss_limit",
                description="å•æ—¥äºæŸè¶…è¿‡10%",
                level=AlertLevel.CRITICAL,
                condition=lambda data: data.get("daily_loss_pct", 0) > 0.10,
                cooldown_minutes=120
            ),
            
            AlertRule(
                name="max_drawdown_exceeded",
                description="æœ€å¤§å›æ’¤è¶…è¿‡15%",
                level=AlertLevel.CRITICAL,
                condition=lambda data: data.get("max_drawdown", 0) > 0.15,
                cooldown_minutes=240
            ),
            
            # âš ï¸ è­¦å‘Šå‘Šè­¦
            AlertRule(
                name="win_rate_drop",
                description="7æ—¥èƒœç‡ä½äº40%",
                level=AlertLevel.WARNING,
                condition=lambda data: data.get("win_rate_7d", 1) < 0.40,
                cooldown_minutes=360
            ),
            
            AlertRule(
                name="consecutive_losses",
                description="è¿ç»­äºæŸ3æ¬¡",
                level=AlertLevel.WARNING,
                condition=lambda data: data.get("consecutive_losses", 0) >= 3,
                cooldown_minutes=60
            ),
            
            # â„¹ï¸ ä¿¡æ¯å‘Šè­¦
            AlertRule(
                name="permission_upgraded",
                description="æƒé™ç­‰çº§æå‡",
                level=AlertLevel.INFO,
                condition=lambda data: data.get("permission_changed", False) and data.get("permission_direction") == "up",
                cooldown_minutes=0
            )
        ]
    
    async def check_alerts(self, data: dict) -> List[dict]:
        """
        æ£€æŸ¥æ‰€æœ‰å‘Šè­¦è§„åˆ™
        
        Args:
            data: å½“å‰ç³»ç»Ÿæ•°æ®
            
        Returns:
            è§¦å‘çš„å‘Šè­¦åˆ—è¡¨
        """
        triggered_alerts = []
        
        for rule in self.rules:
            # æ£€æŸ¥å†·å´æœŸ
            if self._is_in_cooldown(rule):
                continue
            
            # æ£€æŸ¥æ¡ä»¶
            try:
                if rule.condition(data):
                    alert = await self._trigger_alert(rule, data)
                    triggered_alerts.append(alert)
            except Exception as e:
                logger.error(f"å‘Šè­¦è§„åˆ™æ£€æŸ¥å¤±è´¥: {rule.name} - {e}")
        
        return triggered_alerts
    
    async def _trigger_alert(self, rule: AlertRule, data: dict) -> dict:
        """
        è§¦å‘å‘Šè­¦
        """
        alert = {
            "name": rule.name,
            "description": rule.description,
            "level": rule.level.value,
            "data": data,
            "triggered_at": datetime.now().isoformat()
        }
        
        # è®°å½•åˆ°æ•°æ®åº“
        await self._save_alert(alert)
        
        # å‘é€é€šçŸ¥
        await self.notifier.send(alert)
        
        # æ›´æ–°æœ€åè§¦å‘æ—¶é—´
        rule.last_triggered = datetime.now()
        
        logger.warning(f"ğŸš¨ å‘Šè­¦è§¦å‘: {rule.name} - {rule.description}")
        
        return alert
    
    def _is_in_cooldown(self, rule: AlertRule) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦åœ¨å†·å´æœŸå†…
        """
        if rule.last_triggered is None:
            return False
        
        cooldown_delta = timedelta(minutes=rule.cooldown_minutes)
        return datetime.now() - rule.last_triggered < cooldown_delta
    
    async def _save_alert(self, alert: dict):
        """
        ä¿å­˜å‘Šè­¦åˆ°æ•°æ®åº“
        """
        await self.db.execute(
            """
            INSERT INTO alerts (name, description, level, data, triggered_at)
            VALUES (:name, :desc, :level, :data, NOW())
            """,
            {
                "name": alert["name"],
                "desc": alert["description"],
                "level": alert["level"],
                "data": json.dumps(alert["data"])
            }
        )
        await self.db.commit()
```

---

## ğŸ“ˆ æ€§èƒ½åˆ†æå·¥å…·

### å›æµ‹åˆ†æ

```python
# backend/app/services/backtest_analyzer.py

class BacktestAnalyzer:
    """
    å›æµ‹åˆ†æå·¥å…·
    åˆ†æå†å²äº¤æ˜“ï¼Œç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    """
    
    def __init__(self, db_session):
        self.db = db_session
        self.kpi_calc = KPICalculator(db_session)
    
    async def analyze_period(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        åˆ†æç‰¹å®šæ—¶é—´æ®µçš„è¡¨ç°
        """
        # 1. è®¡ç®—KPIs
        kpis = await self.kpi_calc.calculate_all_kpis(start_date, end_date)
        
        # 2. ç”Ÿæˆæƒç›Šæ›²çº¿
        equity_curve = await self._generate_equity_curve(start_date, end_date)
        
        # 3. åˆ†æäº¤æ˜“åˆ†å¸ƒ
        trade_distribution = await self._analyze_trade_distribution(start_date, end_date)
        
        # 4. è¯†åˆ«æœ€ä½³/æœ€å·®äº¤æ˜“
        best_worst = await self._identify_best_worst_trades(start_date, end_date)
        
        return {
            "kpis": kpis,
            "equity_curve": equity_curve,
            "trade_distribution": trade_distribution,
            "best_worst": best_worst,
            "period": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat()
            }
        }
    
    async def _generate_equity_curve(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        ç”Ÿæˆæƒç›Šæ›²çº¿æ•°æ®
        """
        trades = await self.kpi_calc._get_trades(start_date, end_date)
        
        timestamps = []
        equity = []
        cumulative_pnl = 1000.0  # åˆå§‹èµ„é‡‘
        
        for trade in trades:
            timestamps.append(trade["closed_at"].isoformat())
            cumulative_pnl += trade["pnl"]
            equity.append(cumulative_pnl)
        
        return {
            "timestamps": timestamps,
            "equity": equity
        }
    
    async def _analyze_trade_distribution(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        åˆ†æäº¤æ˜“åˆ†å¸ƒ
        """
        trades = await self.kpi_calc._get_trades(start_date, end_date)
        
        # æŒ‰å¸ç§ç»Ÿè®¡
        by_symbol = {}
        # æŒ‰æ–¹å‘ç»Ÿè®¡
        by_side = {"long": 0, "short": 0}
        # æŒ‰æ—¶æ®µç»Ÿè®¡
        by_hour = {i: 0 for i in range(24)}
        
        for trade in trades:
            symbol = trade.get("symbol", "unknown")
            by_symbol[symbol] = by_symbol.get(symbol, 0) + 1
            
            side = trade.get("side", "long")
            by_side[side] += 1
            
            hour = trade["created_at"].hour
            by_hour[hour] += 1
        
        return {
            "by_symbol": by_symbol,
            "by_side": by_side,
            "by_hour": by_hour
        }
    
    async def _identify_best_worst_trades(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """
        è¯†åˆ«æœ€ä½³å’Œæœ€å·®äº¤æ˜“
        """
        trades = await self.kpi_calc._get_trades(start_date, end_date)
        
        # æ’åº
        sorted_trades = sorted(trades, key=lambda t: t["pnl"], reverse=True)
        
        return {
            "best_5": sorted_trades[:5],
            "worst_5": sorted_trades[-5:]
        }
```

---

## ğŸ“„ æŠ¥è¡¨ç”Ÿæˆ

### æ¯æ—¥æŠ¥å‘Š

```python
# backend/app/tasks/daily_report.py

from celery import Celery

celery = Celery("ai_trading")

@celery.task
async def generate_daily_report():
    """
    ç”Ÿæˆæ¯æ—¥æŠ¥å‘Š
    è§¦å‘æ—¶é—´: æ¯å¤© UTC 00:30
    """
    today = datetime.now().date()
    yesterday = today - timedelta(days=1)
    
    # 1. è®¡ç®—æ˜¨æ—¥KPIs
    analyzer = BacktestAnalyzer(db)
    report = await analyzer.analyze_period(
        start_date=datetime.combine(yesterday, datetime.min.time()),
        end_date=datetime.combine(yesterday, datetime.max.time())
    )
    
    # 2. ç”ŸæˆæŠ¥å‘Šå†…å®¹
    report_text = f"""
# AIäº¤æ˜“ç³»ç»Ÿæ¯æ—¥æŠ¥å‘Š
æ—¥æœŸ: {yesterday}

## ğŸ“Š å…³é”®æŒ‡æ ‡
- æ€»äº¤æ˜“æ¬¡æ•°: {report['kpis']['metadata']['total_trades']}
- èƒœç‡: {report['kpis']['win_rate']['win_rate']:.1%}
- æ€»PnL: ${report['kpis']['profitability']['total_return']:.2f}
- å¤æ™®æ¯”ç‡: {report['kpis']['ratios']['sharpe_ratio']:.2f}

## ğŸ¯ é£é™©æŒ‡æ ‡
- æœ€å¤§å›æ’¤: {report['kpis']['risk']['max_drawdown']:.1%}
- æ³¢åŠ¨ç‡: {report['kpis']['risk']['annual_volatility']:.2f}

## ğŸ’¡ å…³é”®æ´å¯Ÿ
{_generate_insights(report)}

---
*ç”±AIäº¤æ˜“ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ*
    """
    
    # 3. å‘é€æŠ¥å‘Š
    await send_report(report_text)
    
    logger.info(f"âœ… æ¯æ—¥æŠ¥å‘Šå·²ç”Ÿæˆ: {yesterday}")

def _generate_insights(report: dict) -> str:
    """
    ç”Ÿæˆå…³é”®æ´å¯Ÿ
    """
    insights = []
    
    kpis = report['kpis']
    
    if kpis['win_rate']['win_rate'] > 0.6:
        insights.append("âœ… èƒœç‡è¡¨ç°ä¼˜ç§€")
    elif kpis['win_rate']['win_rate'] < 0.4:
        insights.append("âš ï¸ èƒœç‡åä½ï¼Œéœ€è¦è°ƒæ•´ç­–ç•¥")
    
    if kpis['profitability']['total_return'] > 0:
        insights.append("âœ… å®ç°ç›ˆåˆ©")
    else:
        insights.append("âš ï¸ å‡ºç°äºæŸ")
    
    return "\n".join(insights) if insights else "æ— ç‰¹æ®Šæƒ…å†µ"
```

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨é˜¶æ®µ**: Phase 1+ï¼ˆæ‰€æœ‰é˜¶æ®µï¼‰  
**æœ€åæ›´æ–°**: 2025-10-31

---

*æœ¬æ–‡æ¡£æä¾›å®Œæ•´çš„ç›‘æ§è¯„ä¼°ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆã€‚å»ºè®®åœ¨Phase 1å³å¼€å§‹å®æ–½åŸºç¡€ç›‘æ§ï¼Œéšç€é¡¹ç›®å‘å±•é€æ­¥å®Œå–„ã€‚*

