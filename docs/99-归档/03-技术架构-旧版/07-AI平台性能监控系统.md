# 🔍 AI平台性能监控系统

> **版本**: v3.2  
> **创建日期**: 2025-11-09  
> **状态**: ✅ 已完成并验证

---

## 📋 目录

1. [系统概述](#系统概述)
2. [技术架构](#技术架构)
3. [数据库设计](#数据库设计)
4. [核心算法](#核心算法)
5. [性能优化](#性能优化)
6. [监控指标](#监控指标)

---

## 系统概述

### 1.1 功能定位

AI平台性能监控系统是AIcoin智能交易系统的核心组成部分，负责实时监控和分析所有AI平台（DeepSeek、Qwen、火山引擎、腾讯云、百度智能云）的调用性能、成功率和响应时间。

### 1.2 核心功能

```
性能监控系统
├── 调用统计
│   ├── 总体统计（调用量、成功率、成本）
│   ├── 各平台统计（按provider分组）
│   └── 峰值时段分析（小时级聚合）
├── 成功率分析
│   ├── 成功率排行榜
│   ├── 失败原因分析（7种分类）
│   └── 稳定性趋势（7天数据）
└── 响应时间分析
    ├── 响应时间排行
    ├── P50/P95/P99延迟分析
    └── 响应时间趋势（7天数据）
```

### 1.3 技术特点

- ✅ **实时监控**: 基于真实调用日志，秒级更新
- ✅ **多维分析**: 调用量、成功率、响应时间三维评估
- ✅ **智能诊断**: 自动分类失败原因，提供解决建议
- ✅ **趋势预测**: 基于历史数据预测稳定性
- ✅ **高性能**: PostgreSQL聚合查询 + 异步处理

---

## 技术架构

### 2.1 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        前端 (Next.js)                        │
├─────────────────────────────────────────────────────────────┤
│  /admin/ai-platforms/stats          调用统计页面             │
│  /admin/ai-platforms/success-rate   成功率分析页面           │
│  /admin/ai-platforms/response-time  响应时间页面             │
└─────────────────────────────────────────────────────────────┘
                            ↓ HTTP/REST
┌─────────────────────────────────────────────────────────────┐
│                    后端 API (FastAPI)                        │
├─────────────────────────────────────────────────────────────┤
│  GET /api/v1/ai-platforms/stats                             │
│  GET /api/v1/ai-platforms/hourly-stats                      │
│  GET /api/v1/ai-platforms/failure-analysis                  │
│  GET /api/v1/ai-platforms/stability-trend                   │
│  GET /api/v1/ai-platforms/response-time-percentiles         │
│  GET /api/v1/ai-platforms/response-time-trend               │
└─────────────────────────────────────────────────────────────┘
                            ↓ SQLAlchemy (Async)
┌─────────────────────────────────────────────────────────────┐
│                    数据库 (PostgreSQL)                       │
├─────────────────────────────────────────────────────────────┤
│  intelligence_platform      AI平台配置表                     │
│  ai_model_usage_log         AI调用日志表 (核心)              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 数据流

```
AI调用 → 记录日志 → 聚合查询 → API响应 → 前端渲染
  ↓         ↓          ↓          ↓          ↓
实时    timestamp   GROUP BY   JSON      可视化
调用    success     DATE_TRUNC  格式      图表
        response_time
        error_message
```

### 2.3 技术栈

#### 后端
- **框架**: FastAPI 0.104+
- **ORM**: SQLAlchemy 2.0 (异步模式)
- **数据库**: PostgreSQL 15+
- **查询优化**: 
  - 直接使用 `sqlalchemy.table` 定义表结构
  - 使用 `func.date_trunc` 进行时间聚合
  - 使用 `func.percentile_cont` 计算分位数

#### 前端
- **框架**: Next.js 14 (App Router)
- **语言**: TypeScript
- **状态管理**: React Hooks (useState, useEffect)
- **样式**: Tailwind CSS

---

## 数据库设计

### 3.1 核心表结构

#### `ai_model_usage_log` (AI调用日志表)

```sql
CREATE TABLE ai_model_usage_log (
    id SERIAL PRIMARY KEY,
    model_name VARCHAR(100) NOT NULL,           -- 模型名称
    prompt_tokens INTEGER,                      -- 输入token数
    completion_tokens INTEGER,                  -- 输出token数
    cost DECIMAL(10, 6),                        -- 调用成本 (元)
    timestamp TIMESTAMP DEFAULT NOW(),          -- 调用时间
    success BOOLEAN DEFAULT TRUE,               -- 是否成功
    error_message TEXT,                         -- 错误信息
    response_time FLOAT,                        -- 响应时间 (毫秒)
    purpose VARCHAR(100)                        -- 调用目的
);

-- 索引优化
CREATE INDEX idx_usage_timestamp ON ai_model_usage_log(timestamp);
CREATE INDEX idx_usage_model_name ON ai_model_usage_log(model_name);
CREATE INDEX idx_usage_success ON ai_model_usage_log(success);
CREATE INDEX idx_usage_timestamp_success ON ai_model_usage_log(timestamp, success);
```

### 3.2 模型名称匹配规则

```python
model_patterns = {
    'deepseek': ['deepseek'],
    'qwen': ['qwen'],
    'volcano': ['volcano', 'doubao'],
    'tencent': ['hunyuan', 'tencent'],
    'baidu': ['ernie', 'baidu', 'wenxin']
}

# SQL正则匹配
WHERE LOWER(model_name) ~ '(deepseek|qwen|volcano|tencent|baidu)'
```

### 3.3 查询优化策略

#### 1. 直接定义表结构（绕过ORM不一致）

```python
from sqlalchemy import table, column

usage_log_table = table('ai_model_usage_log',
    column('id'),
    column('model_name'),
    column('timestamp'),      # 使用实际数据库列名
    column('cost'),
    column('success'),
    column('error_message'),
    column('response_time')
)
```

#### 2. 时间聚合查询

```python
# 按小时聚合
time_column = func.date_trunc('hour', usage_log_table.c.timestamp)
query = select(
    time_column.label('hour'),
    func.count(usage_log_table.c.id).label('calls'),
    func.sum(cast(usage_log_table.c.success, Integer)).label('successful')
).group_by(time_column)
```

#### 3. 分位数计算

```python
query = select(
    func.percentile_cont(0.50).within_group(usage_log_table.c.response_time).label('p50'),
    func.percentile_cont(0.95).within_group(usage_log_table.c.response_time).label('p95'),
    func.percentile_cont(0.99).within_group(usage_log_table.c.response_time).label('p99')
).where(
    and_(
        usage_log_table.c.timestamp >= start_time,
        usage_log_table.c.success == True,
        usage_log_table.c.response_time != None
    )
)
```

---

## 核心算法

### 4.1 失败原因分类算法

```python
def categorize_error(error_message: str) -> str:
    """根据错误信息自动分类"""
    if not error_message:
        return "其他错误"
    
    error_lower = error_message.lower()
    
    # 网络错误
    if any(kw in error_lower for kw in ['network', 'connection', 'dns']):
        return "网络错误"
    
    # 认证失败
    elif any(kw in error_lower for kw in ['auth', 'unauthorized', 'invalid api key']):
        return "认证失败"
    
    # 频率限制
    elif any(kw in error_lower for kw in ['rate limit', 'too many requests', 'qpm']):
        return "频率限制"
    
    # 配额不足
    elif any(kw in error_lower for kw in ['quota', 'insufficient', 'balance']):
        return "配额不足"
    
    # 请求超时
    elif any(kw in error_lower for kw in ['timeout', 'timed out']):
        return "请求超时"
    
    # 参数错误
    elif any(kw in error_lower for kw in ['invalid', 'bad request', 'parameter']):
        return "参数错误"
    
    else:
        return "其他错误"
```

### 4.2 稳定性评分算法

```python
def calculate_stability_score(data_points: List[dict]) -> float:
    """
    计算稳定性评分
    考虑因素:
    1. 平均成功率 (70%)
    2. 成功率标准差 (30%) - 越小越稳定
    """
    if not data_points:
        return 0.0
    
    success_rates = [p['success_rate'] for p in data_points]
    avg_rate = sum(success_rates) / len(success_rates)
    
    # 计算标准差
    variance = sum((x - avg_rate) ** 2 for x in success_rates) / len(success_rates)
    std_dev = variance ** 0.5
    
    # 稳定性评分 = 平均成功率 * 0.7 + (100 - 标准差) * 0.3
    stability = avg_rate * 0.7 + (100 - std_dev) * 0.3
    
    return round(stability, 2)
```

### 4.3 峰值时段识别算法

```python
def identify_peak_hour(hourly_stats: List[dict]) -> dict:
    """识别调用量最高的小时"""
    if not hourly_stats:
        return None
    
    # 按调用量排序
    sorted_stats = sorted(hourly_stats, key=lambda x: x['calls'], reverse=True)
    
    return sorted_stats[0]  # 返回调用量最高的小时
```

---

## 性能优化

### 5.1 数据库优化

#### 1. 索引策略

```sql
-- 时间范围查询优化
CREATE INDEX idx_usage_timestamp ON ai_model_usage_log(timestamp);

-- 模型名称查询优化
CREATE INDEX idx_usage_model_name ON ai_model_usage_log(model_name);

-- 成功标志查询优化
CREATE INDEX idx_usage_success ON ai_model_usage_log(success);

-- 复合索引（时间+成功标志）
CREATE INDEX idx_usage_timestamp_success 
ON ai_model_usage_log(timestamp, success);
```

#### 2. 查询优化

```python
# 使用聚合函数减少数据传输
query = select(
    func.count(*).label('total'),
    func.sum(case((usage_log_table.c.success == True, 1), else_=0)).label('successful'),
    func.avg(usage_log_table.c.response_time).label('avg_time')
).where(usage_log_table.c.timestamp >= start_time)

# 使用EXPLAIN ANALYZE分析查询性能
EXPLAIN ANALYZE SELECT ...
```

#### 3. 分区表（大数据量场景）

```sql
-- 按月分区
CREATE TABLE ai_model_usage_log_2025_11 PARTITION OF ai_model_usage_log
FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

CREATE TABLE ai_model_usage_log_2025_12 PARTITION OF ai_model_usage_log
FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');
```

### 5.2 后端优化

#### 1. 异步查询

```python
async def get_platform_stats(time_range: str, db: AsyncSession):
    """异步查询平台统计"""
    query = select(...)
    result = await db.execute(query)
    return result.scalars().all()
```

#### 2. 查询缓存（规划中）

```python
from functools import lru_cache
from datetime import datetime

@lru_cache(maxsize=128)
def get_cached_stats(time_range: str, cache_key: str):
    """缓存统计数据（5分钟）"""
    # 实际查询逻辑
    pass

# 使用时
cache_key = f"{time_range}_{datetime.now().strftime('%Y%m%d%H%M')}"
data = get_cached_stats(time_range, cache_key)
```

### 5.3 前端优化

#### 1. 防抖/节流

```typescript
import { useCallback } from 'react';
import { debounce } from 'lodash';

const debouncedFetch = useCallback(
  debounce((timeRange) => {
    fetchData(timeRange);
  }, 300),
  []
);
```

#### 2. 懒加载

```typescript
const [showTrend, setShowTrend] = useState(false);

// 只在用户点击时加载趋势数据
const handleShowTrend = () => {
  setShowTrend(true);
  fetchTrendData();
};
```

---

## 监控指标

### 6.1 核心指标定义

#### 调用量指标

| 指标 | 定义 | 计算公式 | 用途 |
|-----|------|---------|------|
| 总调用次数 | 所有AI API调用的总数 | `COUNT(*)` | 评估系统活跃度 |
| 成功调用 | 返回成功的调用数 | `COUNT(*) WHERE success = true` | 评估可用性 |
| 失败调用 | 返回失败的调用数 | `COUNT(*) WHERE success = false` | 识别故障 |
| 调用量占比 | 单平台调用量占总量的比例 | `平台调用量 / 总调用量 × 100%` | 评估平台使用分布 |

#### 成功率指标

| 指标 | 定义 | 计算公式 | 阈值 |
|-----|------|---------|------|
| 成功率 | 成功调用占总调用的比例 | `成功调用 / 总调用 × 100%` | ≥ 95% |
| 稳定性评分 | 综合成功率和波动性的评分 | `平均成功率 × 0.7 + (100 - 标准差) × 0.3` | ≥ 90 |

#### 响应时间指标

| 指标 | 定义 | 说明 | 目标值 |
|-----|------|------|--------|
| 平均响应时间 | 所有请求的平均响应时间 | `AVG(response_time)` | < 1500ms |
| P50 (中位数) | 50%的请求响应时间低于此值 | `PERCENTILE_CONT(0.50)` | < 1000ms |
| P95 | 95%的请求响应时间低于此值 | `PERCENTILE_CONT(0.95)` | < 2000ms |
| P99 | 99%的请求响应时间低于此值 | `PERCENTILE_CONT(0.99)` | < 3000ms |

### 6.2 性能标准

#### 成功率标准

| 等级 | 成功率范围 | 评价 | 建议 |
|-----|-----------|------|------|
| 优秀 | ≥ 99% | 非常稳定 | 继续保持 |
| 良好 | 95% - 99% | 稳定 | 监控波动 |
| 一般 | 90% - 95% | 基本可用 | 排查失败原因 |
| 较差 | 80% - 90% | 不稳定 | 考虑切换平台 |
| 很差 | < 80% | 严重故障 | 立即停用 |

#### 响应时间标准

| 等级 | 响应时间 | 评价 | 用户体验 |
|-----|---------|------|---------|
| 优秀 | < 500ms | 实时响应 | 无感知延迟 |
| 良好 | 500-1000ms | 流畅 | 轻微延迟 |
| 一般 | 1-2秒 | 可接受 | 明显延迟 |
| 较慢 | 2-5秒 | 较慢 | 影响体验 |
| 很慢 | > 5秒 | 严重卡顿 | 不可接受 |

### 6.3 告警规则（规划中）

| 告警类型 | 触发条件 | 严重级别 | 处理时效 |
|---------|---------|---------|---------|
| 成功率告警 | 成功率 < 90% | 🔴 严重 | 立即处理 |
| 响应时间告警 | P95 > 3000ms | 🟡 警告 | 1小时内 |
| 调用量异常 | 调用量下降 > 50% | 🟠 中等 | 2小时内 |
| 平台故障 | 连续失败 > 10次 | 🔴 严重 | 立即处理 |
| 配额预警 | 剩余配额 < 20% | 🟡 警告 | 24小时内 |

---

## 相关文档

- [前端功能模块说明](../08-前端系统/01-功能模块说明.md#106-ai平台性能监控-v32新增)
- [API接口文档](../09-API接口文档/README.md#95-ai平台性能监控-v32新增)
- [系统架构设计](./00-系统架构设计.md)

---

**文档版本**: v3.2  
**最后更新**: 2025-11-09  
**维护状态**: ✅ Active  
**维护者**: AIcoin Team

